### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

> 给定一个含有 n 个正整数的数组和一个正整数 target 。
> 
> 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

其实更像一道滑窗题，没懂二分在哪里

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        // 边界处理
        if (nums.size() == 0){
            return 0;
        } 
        if (nums.size() == 1){
            if (nums[0] >= target){
                return 1;
            }
            else{
                return 0;
            }
        }
        // 左右两个指针，进行滑窗
        int left=0, right=0, sum=0;
        int res = nums.size() + 1; // 异常值，最后有用
        while (left < nums.size()){ // 只限制左边界就可以
            // 寻找达标的右边界
            if (right < nums.size() && sum < target){ // 右边界在这里被限制，不会越界
                sum += nums[right];
                right += 1;
            }
            // 目前的l-r区间内已达标。缩左边界直到不达标，然后更新结果
            else{
                sum -= nums[left];
                left += 1;
            }
            if (sum >= target){
                // 此处的左边界下标是被加过1的，计算滑窗长度时不需要+1
                res = min(res, right-left);
            }
        }
        if (res == nums.size() + 1){
            return 0;
        }
        else{
            return res;
        }
    }
};
```